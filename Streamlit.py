import streamlit as st
import torch
import langdetect
from transformers import DistilBertForSequenceClassification, DistilBertTokenizer
import spacy
from nltk.corpus import stopwords
from textblob import TextBlob
from langdetect import detect
import nltk
import re

    ## Setting up the Streamlit page

st.set_page_config(page_title="Customer Support Assistant", page_icon=":robot_face:", layout="wide")
st.markdown("""
    <style>
        .big-font {
            font-size:30px !important;
            font-weight: bold;
            color: #1f77b4;  # Adjusted for a pleasant blue theme
        }
        .streamlit-text-area {
            height: 150px !important;
            font-size: 20px;
        }
        .streamlit-button {
            height: 3em;
            width: 20em;
            font-size: 18px;
            background-color: #1f77b4;
            color: white;
        }
    </style>
    """, unsafe_allow_html=True)



    ## Loading pre-trained model and tokenizer

model_path = "./new_distilbert-category-multilingual-classifier-model"#"/Users/tania_ren/Downloads/distilbertModel" #"/Users/tania_ren/Downloads/distilbert-category-multilingual-classifier/"
model = DistilBertForSequenceClassification.from_pretrained(model_path)

tokenizer_path = "./new_distilbert-category-multilingual-tokenizer" #"/Users/tania_ren/Downloads/distilbert-category-multilingual-classifier/"#
tokenizer = DistilBertTokenizer.from_pretrained(tokenizer_path)


    ## Label map - IDs and Labes

label_map = {
    1: "Software",
    0: "Hardware",
    2: "Accounting"
}


    ## Preprocessing and prediction steps

# stopwords 
nltk.download('stopwords')
german_stopwords = set(stopwords.words('german'))
english_stopwords = set(stopwords.words('english'))

def clean_and_lemmatize(texts):
    return [preprocess_text(text) for text in texts]  # Ensure each text is processed

# function to preprocess text
def classify_text(text):
    text = re.sub(r'[^\w\s]', '', text)  # punctuation
    text = re.sub(r'\d+', '', text)  # digits
    text = text.lower()  # lowercasing

# tokenizing text
    inputs = tokenizer.encode_plus(
        text,
        return_tensors="pt",
        padding='max_length',
        truncation=True,
        max_length=128  # Consistent max_length for all inputs
    )

# predicting with no gradient calculation (efficient)
    with torch.no_grad():
        logits = model(**inputs).logits
        
    
    inputs = tokenizer.encode_plus(text, return_tensors="pt", padding=True, truncation=True, max_length=128)
    with torch.no_grad():
        logits = model(**inputs).logits

# getting the predicted class ID and mapping it to the label
    predicted_class_id = logits.argmax().item()
    return label_map.get(predicted_class_id, "Unknown label")


    ## Sentiment
    

#sentiment function
def analyze_sentiment(text):
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity
    return "positive" if polarity > 0 else "negative" if polarity < 0 else "neutral"


    ## Interface design and the customer inquiry area

st.title('Customer Support Portal')
st.markdown(""" 
    <style>
        .small-font {
            font-size: 20px; /* Setting the font size to 20px */
            color: #4a69bd; /* Setting the text color to a calm blue */
        }
    </style>
    <p class="small-font">Welcome to the customer support form! Please type your inquiry below.</p>
""", unsafe_allow_html=True)


#layout columns
col1, col2 = st.columns([1, 2]) 

#robot picture - the left column
with col1:
    st.image("./robot_image.png", caption='"Cute robot dealing with tickets" - Image generated by DALL-E.')

#text area & button - the right column
with col2:
    #text area for user input
    user_input = st.text_area("Please enter your query here:", "", help="Type any customer support related query here.")


#button submit - to respond based on the classified inquiry type & sentiment of user input 
    if st.button('Submit'):
        if user_input.strip() != "":
            with st.spinner('Analyzing your request...'):
                category_label = classify_text(user_input)
                sentiment = analyze_sentiment(user_input)

                response_messages = {
                    "Software": {
                        "positive": "Dear Customer, your query has been classified as Software. We're excited to direct you to the relevant tools and resources to assist you further. Our support team is on the way to help you with all your needs.",
                        "neutral": "Dear Customer! Thank you for reaching out about your Software inquiry. We're here to guide you to the right tools and resources you need to succeed. Our specialist is on the way to assist you with all your needs.",
                        "negative": "Dear Valued Customer, we're genuinely sorry to hear about your frustration with Software issues. Please know we're on your side and ready to resolve these issues together."
                    },
                    "Hardware": {
                        "positive": "Dear Customer, your interest in our Hardware solutions is appreciated. We’re excited to offer you the support and resources needed for your success. A dedicated support member will assist you shortly.",
                        "neutral": "Dear Customer! We've received your inquiry regarding Hardware. We're committed to providing the technical support necessary for your projects. A technician is on their way to ensure you have everything you need.",
                        "negative": "Dear Valued Customer, we're genuinely sorry to hear about your frustration with Hardware issues. Please know we're on your side and are here to tackle these challenges together promptly."
                    },
                    "Accounting": {
                        "positive": "Dear Customer, your enthusiasm for Accounting matters is highly valued. We're thrilled to provide you with expert advice and resources. Our finance specialist will be in touch soon to guide you.",
                        "neutral": "Dear Customer! Your inquiry about Accounting has been noted. We're ready to assist you with detailed and precise advice. Our expert is preparing the best solutions for you right now.",
                        "negative": "Dear Valued Customer, we understand that Accounting issues can be daunting. We’re committed to helping you sort these out with the utmost urgency and care."
                    }
                }

                #default message - if unable to classify
                default_message = "Dear Customer, We're unable to classify your query. Please try again or provide more details.Additionally, you can contact us on JohnDoe@customersupport.com"
                if category_label in response_messages:
                    st.success(response_messages[category_label].get(sentiment, default_message))
                else:
                    st.error(default_message)

            
#sidebar for additional inform
with st.sidebar:
    st.header("About the Tool")
    st.info("""
        This tool uses Natural Language Processing powered by DistilBERT model to classify customer support queries.
        It's designed to demonstrate a potential application in a real-world customer support scenario.
    """)

    st.markdown("_Current model understands English and German Languages for input._")

#Control visibility of Instructions
    if 'show_instructions' not in st.session_state:
        st.session_state.show_instructions = False

# Toggle button for Instructions with arrow
    instruction_arrow = "▼" if not st.session_state.show_instructions else "▲"
    if st.sidebar.button(f"Toggle Instructions {instruction_arrow}"):
        st.session_state.show_instructions = not st.session_state.show_instructions

#instructions when visibile
    if st.session_state.show_instructions:
        st.header("How to Use")
        st.markdown("""
        - Enter your customer support related issue in the text area on the right.
        - Press the 'Submit' button to see the category of your request.
        - Wait for the instant automated response.
        """)

        
        
#Control visibility of FAQs
    if 'show_faq' not in st.session_state:
        st.session_state.show_faq = False

# Toggle button for FAQs with arrow
    faq_arrow = "▼" if not st.session_state.show_faq else "▲"
    if st.sidebar.button(f"Toggle FAQs {faq_arrow}"):
        st.session_state.show_faq = not st.session_state.show_faq

#FAQs when visible
    if st.session_state.show_faq:
        st.header("Frequently Asked Questions")
        st.markdown("""
        **Q: How accurate is the tool's classification?**  
        A: Our tool achieves high accuracy, but as with any automated system, there may occasionally be misclassifications.

        **Q: Do you use my data to train your model?**  
        A: No, no customer data is used for further training.

        **Q: What should I do if my query is misclassified?**  
        A: Please provide feedback using the 'Report Issue' button below, and our team will use your input to improve the system.

        **Q: Is my data kept private when using this tool?**  
        A: Yes, we respect your privacy, and no personal data is stored or used beyond the classification process.
        """)
        
#Make instruction text is always visible
    st.sidebar.markdown('<small style="color: gray;">To close the instructions and FAQ, please press twice.</small>', unsafe_allow_html=True) 

#Placeholder button - Report Issue
    st.markdown("""
        <style>
        .report-button {
            background-color: #ff4b4b;
            color: white;
            padding: 0.5em;
            border: none;
            border-radius: 10px; /* Increased border-radius for more rounded edges */
            text-align: center;
            font-size: 0.75em;
            margin: 0.5em 0;
            cursor: pointer;
        }
        .report-button:hover {
            background-color: #ff0000;
        }
        </style>
    """, unsafe_allow_html=True)


    st.sidebar.markdown('<button class="report-button">Report Issue</button>', unsafe_allow_html=True)
